import Iterable from 'jsiterable';
import { JsonldKeywords } from '../src/constants';
import { Errors } from '../src/errors';
import { Edge, Vertex } from '../src/types';

const PREFIX_REGEX = /^[a-zA-z][a-zA-Z0-9_]*$/;

export default class GraphIndex<V extends Vertex, E extends Edge<V>> {
    private readonly _edges = new Map<string, E>();
    private readonly _vertices = new Map<string, V>();
    private readonly _index = new Map<string, Set<string>>();
    private readonly _prefixes = new Map<string, string>();

    private static IX_EDGES_KEY = (label: string) => `[e]::${label}`;
    private static IX_NODE_INCOMING_ALL_KEY = (id: string) => `[v]::${id}_[in]`;
    private static IX_NODE_INCOMING_EDGES = (id: string, label: string) =>
        `[v]::${id}_[in]_[e]::${label}`;
    private static IX_NODE_OUTGOING_ALL = (id: string) => `[v]::${id}_[out]`;
    private static IX_NODE_OUTGOING_EDGES = (id: string, label: string) =>
        `[v]::${id}_[out]_[e]::${label}`;

    /**
     * @description Gets the no of edges in the index.
     * @readonly
     * @type {number}
     * @memberof GraphIndex
     */
    get edgeCount(): number {
        return this._edges.size;
    }

    /**
     * @description Gets the no of vertices in the index.
     * @readonly
     * @type {number}
     * @memberof GraphIndex
     */
    get vertexCount(): number {
        return this._vertices.size;
    }

    /**
     * @description Adds an edge to the index.
     * @param {Edge} edge The edge to add to the index.
     * @memberof GraphIndex
     */
    addEdge(edge: E): void {
        if (!edge) {
            throw new ReferenceError(`Invalid edge. id is ${edge}`);
        }

        if (!edge.label) {
            throw new ReferenceError(`Invalid edge.label. edge.label is '${edge.label}`);
        }

        if (!edge.from) {
            throw new ReferenceError(
                `Invalid edge.fromVertexIRI. edge.fromVertexIRI is '${edge.from}`
            );
        }

        if (!edge.to) {
            throw new ReferenceError(`Invalid edge.toVertexIRI. edge.toVertexIRI is '${edge.to}`);
        }

        const labelIRI = this.expandIRI(edge.label);
        const fromVertexIRI = this.expandIRI(edge.from.id);
        const toVertexIRI = this.expandIRI(edge.to.id);

        if (!this._vertices.has(fromVertexIRI)) {
            throw new Errors.VertexNotFoundError(fromVertexIRI);
        }

        if (!this._vertices.has(toVertexIRI)) {
            throw new Errors.VertexNotFoundError(toVertexIRI);
        }

        if (fromVertexIRI.toLowerCase() === toVertexIRI.toLowerCase()) {
            throw new Errors.CyclicEdgeError(labelIRI, fromVertexIRI);
        }

        const edgeId = this._formatEdgeId(labelIRI, fromVertexIRI, toVertexIRI);
        if (this._edges.has(edgeId)) {
            throw new Errors.DuplicateEdgeError(labelIRI, fromVertexIRI, toVertexIRI);
        }

        this._edges.set(edgeId, edge);
        for (const indexKey of this._generateEdgeIndexKeys(edge)) {
            if (!this._index.has(indexKey)) {
                this._index.set(indexKey, new Set<string>());
            }

            this._index.get(indexKey).add(edgeId);
        }
    }

    /**
     * @description Adds a prefix for an IRI
     * @param {string} prefix The prefix to add.
     * @param {string} iri The IRI mapped to the prefix.
     * @memberof GraphIndex
     */
    addIRIPrefix(prefix: string, iri: string): void {
        if (!prefix) {
            throw new ReferenceError(`Invalid prefix. prefix is '${prefix}'`);
        }

        this.validateIRI(iri);

        if (!prefix.match(PREFIX_REGEX)) {
            throw new Errors.InvalidPrefixError(
                prefix,
                'Invalid prefix. Prefixes must contain only alpha-characters.'
            );
        }

        if (this._prefixes.has(prefix)) {
            throw new Errors.DuplicatePrefixError(prefix);
        }

        for (const [, mappedId] of this._prefixes) {
            if (mappedId.toLowerCase() === iri.toLowerCase()) {
                throw new Errors.DuplicatePrefixIRIError(prefix, iri);
            }
        }

        this._prefixes.set(prefix, iri);
    }

    /**
     * @description Adds a vertex to the index.
     * @param {Vertex} vertex The vertex instance to add to the index.
     * @memberof GraphIndex
     */
    addVertex(vertex: V): void {
        if (!vertex) {
            throw new ReferenceError(`Invalid vertex. vertex is ${vertex}`);
        }

        const vertexIRI = this.expandIRI(vertex.id);
        if (this._vertices.has(vertexIRI)) {
            throw new Errors.DuplicateVertexError(vertexIRI);
        }

        this._vertices.set(vertexIRI, vertex);
    }

    /**
     * @description Compacts an IRI with a mapped prefix.
     * @param {string} iri The IRI string to compact.
     * @returns {string}
     * @memberof GraphIndex
     */
    compactIRI(iri: string): string {
        this.validateIRI(iri);
        for (const [prefix, mappedIRI] of this._prefixes) {
            if (iri.startsWith(mappedIRI) && mappedIRI.toLowerCase() !== iri.toLowerCase()) {
                let compacted = iri.replace(mappedIRI, '');
                if (compacted.startsWith('/') || compacted.startsWith(':')) {
                    compacted = compacted.slice(1, compacted.length);
                }

                return `${prefix}:${compacted}`;
            }
        }

        return iri;
    }

    /**
     * @description Expands a compacted IRI.
     * @param {string} iri The compacted IRI to expand.
     * @returns {string}
     * @memberof GraphIndex
     */
    expandIRI(iri: string): string {
        if (!iri) {
            throw new ReferenceError(`Invalid iri. iri is '${iri}'`);
        }

        const prefixIndex = iri.indexOf(':');
        if (prefixIndex <= 0) {
            return iri;
        }

        const prefix = iri.substring(0, prefixIndex);
        const component = iri.substring(prefixIndex + 1);
        if (this._prefixes.has(prefix)) {
            return `${this._prefixes.get(prefix)}${component}`;
        } else {
            return iri;
        }
    }

    /**
     * @description Gets an edge.
     * @param {string} label The label of the edge to get.
     * @param {string} fromVertexId The id of the outgoing vertex.
     * @param {string} toVertexId The id of the incoming vertex.
     * @returns {Edge} The edge instance or undefined if not found
     * @memberof GraphIndex
     */
    getEdge(label: string, fromVertexId: string, toVertexId: string): E {
        if (!label) {
            throw new ReferenceError(`Invalid label. label is '${label}`);
        }
        if (!fromVertexId) {
            throw new ReferenceError(`Invalid fromVertexId. fromVertexId is '${fromVertexId}'`);
        }
        if (!toVertexId) {
            throw new ReferenceError(`Invalid toVertexId. toVertexId is '${toVertexId}'`);
        }

        const labelIRI = this.expandIRI(label);
        const fromVertexIRI = this.expandIRI(fromVertexId);
        const toVertexIRI = this.expandIRI(toVertexId);

        this.validateIRI(labelIRI);
        this.validateIRI(fromVertexIRI);
        this.validateIRI(toVertexIRI);

        return this._edges.get(this._formatEdgeId(labelIRI, fromVertexIRI, toVertexIRI));
    }

    /**
     * @description Gets all edges, optionally with the specified label.
     * @param {string} [label] Optional. The label of the edge to fetch.
     * @returns {IterableIterator<Edge>}
     * @memberof GraphIndex
     */
    *getEdges(label?: string): IterableIterator<E> {
        if (!label) {
            for (const [, edge] of this._edges) {
                yield edge;
            }
        } else {
            const labelIRI = this.expandIRI(label);
            this.validateIRI(labelIRI);

            const indexKey = GraphIndex.IX_EDGES_KEY(labelIRI);
            if (!this._index.has(indexKey)) {
                return;
            }

            for (const edgeId of this._index.get(indexKey)) {
                yield this._edges.get(edgeId);
            }
        }
    }

    /**
     * @description Gets all vertices that haven an incoming edge with the specified label.
     * @param {string} label The label of the edge.
     * @returns {IterableIterator<Vertex>}
     * @memberof GraphIndex
     */
    *getEdgeIncoming(label: string): IterableIterator<V> {
        if (!label) {
            throw new ReferenceError(`Invalid label. label is '${label}`);
        }

        const labelIRI = this.expandIRI(label);
        this.validateIRI(labelIRI);

        const indexKey = GraphIndex.IX_EDGES_KEY(labelIRI);
        if (!this._index.has(indexKey)) {
            return;
        }

        const visited = new Set<string>();
        for (const edgeKey of this._index.get(indexKey)) {
            const edge = this._edges.get(edgeKey);
            if (!visited.has(edge.to.id) && this._vertices.has(edge.to.id)) {
                visited.add(edge.to.id);
                yield edge.to;
            }
        }
    }

    /**
     * @description Gets all vertices that have an outgoing edge with the specified label.
     * @param {string} label The label of the edge.
     * @returns {IterableIterator<Vertex>}
     * @memberof GraphIndex
     */
    *getEdgeOutgoing(label: string): IterableIterator<V> {
        if (!label) {
            throw new ReferenceError(`Invalid label. label is '${label}'`);
        }

        const labelIRI = this.expandIRI(label);
        this.validateIRI(labelIRI);

        const indexKey = GraphIndex.IX_EDGES_KEY(labelIRI);
        if (!this._index.has(indexKey)) {
            return;
        }

        const visited = new Set<string>();
        for (const edgeKey of this._index.get(indexKey)) {
            const edge = this._edges.get(edgeKey);
            if (!visited.has(edge.from.id) && this._vertices.has(edge.from.id)) {
                visited.add(edge.from.id);
                yield edge.from;
            }
        }
    }

    /**
     * @description Gets the prefix for an id, if one exists.
     * @param {string} iri The IRI whose prefix should be returned.
     * @returns {string} The mapped prefix for the id.
     * @memberof GraphIndex
     */
    getPrefix(iri: string): string {
        if (!iri) {
            throw new ReferenceError(`Invalid iri. iri is '${iri}'`);
        }

        return new Iterable(this._prefixes.entries())
            .filter(([, mappedIRI]) => iri.startsWith(mappedIRI))
            .map(([prefix]) => prefix)
            .first();
    }

    /**
     * @description Gets a vertex.
     * @param {string} id The IRI of the vertex to get.
     * @returns {Vertex} The vertex instance.
     * @memberof GraphIndex
     */
    getVertex(id: string): V {
        if (!id) {
            throw new ReferenceError(`Invalid id. id is '${id}'`);
        }

        const vertexIRI = this.expandIRI(id);
        return this._vertices.get(vertexIRI);
    }

    /**
     * @description Gets all vertices with outgoing edges to the specified vertex.
     * @param {string} id The id of the vertex w
     * @param {string} [label]
     * @returns {IterableIterator<{ edge: Edge; vertex: Vertex }>}
     * @memberof GraphIndex
     */
    *getVertexIncoming(id: string, label?: string): IterableIterator<E> {
        if (!id) {
            throw new ReferenceError(`Invalid id. id is '${id}'`);
        }

        if (!this._vertices.has(id)) {
            throw new Errors.VertexNotFoundError(id);
        }

        const vertexIRI = this.expandIRI(id);
        let indexKey: string;
        if (label) {
            indexKey = GraphIndex.IX_NODE_INCOMING_EDGES(vertexIRI, this.expandIRI(label));
        } else {
            indexKey = GraphIndex.IX_NODE_INCOMING_ALL_KEY(vertexIRI);
        }

        if (!this._index.has(indexKey)) {
            return;
        }

        for (const edgeId of this._index.get(indexKey)) {
            const edge = this._edges.get(edgeId);
            yield edge;
        }
    }

    /**
     * @description Gets all outgoing vertices from the specified vertex
     * @param {string} id The id of the vertex.
     * @param {string} [label]
     * @returns {IterableIterator<{ edge: Edge; vertex: Vertex }>}
     * @memberof GraphIndex
     */
    *getVertexOutgoing(id: string, label?: string): IterableIterator<E> {
        if (!id) {
            throw new ReferenceError(`Invalid id. id is '${id}'`);
        }

        if (!this._vertices.has(id)) {
            throw new Errors.VertexNotFoundError(id);
        }

        const vertexIRI = this.expandIRI(id);
        let indexKey: string;
        if (label) {
            const labelIRI = this.expandIRI(label);
            indexKey = GraphIndex.IX_NODE_OUTGOING_EDGES(vertexIRI, this.expandIRI(labelIRI));
        } else {
            indexKey = GraphIndex.IX_NODE_OUTGOING_ALL(vertexIRI);
        }

        if (!this._index.has(indexKey)) {
            return;
        }

        for (const edgeId of this._index.get(indexKey)) {
            const edge = this._edges.get(edgeId);
            yield edge;
        }
    }

    /**
     * @description Checks if an edge exists in the index.
     * @param {string} label The label of the edge.
     * @param {string} fromId The id of the from vertex.
     * @param {string} toId The id of the to vertex.
     * @returns {boolean} True if the edge exists, else false.
     * @memberof GraphIndex
     */
    hasEdge(label: string, fromId: string, toId: string): boolean {
        if (!label) {
            throw new ReferenceError(`Invalid label. label is '${label}'`);
        }
        if (!fromId) {
            throw new ReferenceError(`Invalid fromVertexIRI. fromVertexIRI is '${fromId}'`);
        }
        if (!toId) {
            throw new ReferenceError(`Invalid toVertexIRI. toVertexIRI is '${toId}'`);
        }

        const labelIRI = this.expandIRI(label);
        const fromVertexIRI = this.expandIRI(fromId);
        const toVertexIRI = this.expandIRI(toId);
        return this._edges.has(this._formatEdgeId(labelIRI, fromVertexIRI, toVertexIRI));
    }

    /**
     * @description Checks if a prefix exists for the specified IRI.
     * @param {string} iri The IRI to check.
     * @returns {boolean}
     * @memberof GraphIndex
     */
    hasPrefix(iri: string): boolean {
        this.validateIRI(iri);
        return new Iterable(this._prefixes.entries()).some(
            ([, mappedIRI]) => mappedIRI.toLowerCase() === iri.toLowerCase()
        );
    }

    /**
     * @description Checks if a vertex exists in the index.
     * @param {string} id The id of the vertex.
     * @returns {boolean} True if the vertex exists.
     * @memberof GraphIndex
     */
    hasVertex(id: string): boolean {
        const vertexIRI = this.expandIRI(id);
        return this._vertices.has(vertexIRI);
    }

    /**
     * @description Removes a prefix
     * @param {string} prefix The prefix to remove.
     * @memberof GraphIndex
     */
    removeIdPrefix(prefix: string): void {
        if (!prefix) {
            throw new ReferenceError(`Invalid prefix. prefix is '${prefix}'`);
        }

        this._prefixes.delete(prefix);
    }

    /**
     * @description Loose validation of the IRI to conform that it specifies a scheme and authority. Character sets are not validated.
     * @param {string} iri
     * @returns {void}
     * @memberof GraphIndex
     */
    validateIRI(iri: string): void {
        if (!iri) {
            throw new ReferenceError(`Invalid iri. iri is '${iri}'`);
        }

        if (iri === JsonldKeywords.type) {
            return;
        }

        const schemeIndex = iri.indexOf(':');
        if (schemeIndex <= 0) {
            throw new Errors.InvalidIRIError(iri, 'IRI scheme not specified');
        }

        let authority = iri.slice(schemeIndex + 1);
        if (!authority || authority.length === 0) {
            throw new Errors.InvalidIRIError(iri, 'IRI authority not specified');
        }

        if (authority.startsWith('//')) {
            authority = authority.slice(2);
        }

        if (authority.startsWith('/') || authority.startsWith(':')) {
            throw new Errors.InvalidIRIError(iri, 'Malformed IRI authority');
        }

        if (authority.length === 0) {
            throw new Errors.InvalidIRIError(iri, 'IRI authority not specified');
        }
    }

    private _formatEdgeId(label: string, fromVertex: string, toVertex: string): string {
        return `${label}->${fromVertex}->${toVertex}`;
    }

    private _generateEdgeIndexKeys(edge: E): string[] {
        const labelIRI = this.expandIRI(edge.label);
        const fromVertexIRI = this.expandIRI(edge.from.id);
        const toVertexIRI = this.expandIRI(edge.to.id);

        return [
            GraphIndex.IX_EDGES_KEY(labelIRI),
            GraphIndex.IX_NODE_INCOMING_ALL_KEY(fromVertexIRI),
            GraphIndex.IX_NODE_INCOMING_EDGES(toVertexIRI, labelIRI),
            GraphIndex.IX_NODE_OUTGOING_ALL(fromVertexIRI),
            GraphIndex.IX_NODE_OUTGOING_EDGES(fromVertexIRI, labelIRI)
        ];
    }
}
